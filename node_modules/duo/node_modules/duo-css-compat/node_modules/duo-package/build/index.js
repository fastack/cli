
/**
 * Module dependencies
 */

/**
 * Exists
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

var exists = wrapGenerator.mark(function exists(path) {
  return wrapGenerator(function exists$($ctx3) {
    while (1) switch ($ctx3.prev = $ctx3.next) {
    case 0:
      $ctx3.prev = 0;
      $ctx3.next = 3;
      return fs.stat(path);
    case 3:
      return $ctx3.abrupt("return", true);
    case 6:
      $ctx3.prev = 6;
      $ctx3.t1 = $ctx3.catch(0);
      return $ctx3.abrupt("return", false);
    case 9:
    case "end":
      return $ctx3.stop();
    }
  }, exists, this, [[0, 6]]);
});

var debug = require('debug')('duo-package');
var Emitter = require('events').EventEmitter;
var write = require('fs').createWriteStream;
var read = require('fs').createReadStream;
var resolve = require('gh-resolve');
var mkdir = require('mkdirp').sync;
var netrc = require('node-netrc');
var fmt = require('util').format;
var enstore = require('enstore');
var request = require('request');
var tmp = require('os').tmpdir();
var thunk = require('thunkify');
var semver = require('semver');
var tar = require('tar-fs');
var path = require('path');
var zlib = require('zlib');
var fs = require('co-fs');
var url = require('url');
var join = path.join;

/**
 * Export `Package`
 */

module.exports = Package;

/**
 * Thunkify functions
 */

resolve = thunk(resolve);

/**
 * Inflight
 */

var inflight = {};

/**
 * Refs.
 */

var refs = {};

/**
 * Home directory
 */

var home = process.env.HOME || process.env.HOMEPATH;

/**
 * Cache tarballs in "$tmp/duo"
 * and make sure it exists
 */

var cachepath = join(tmp, 'duo');

mkdir(cachepath);

/**
 * API url
 */

var api = 'https://api.github.com';

/**
 * auth from ~/.netrc
 */

var auth = netrc('api.github.com') || {
  login: process.env.GH_USER,
  password: process.env.GH_TOKEN
};

/**
 * Logging
 */

auth.login && auth.password
  ? debug('read auth details from ~/.netrc')
  : debug('could not read auth details from ~/.netrc')

/**
 * Initialize `Package`
 *
 * @param {String} repo
 * @param {String} ref
 * @api public
 */;

/**
 * Initialize `Package`
 *
 * @param {String} repo
 * @param {String} ref
 * @api public
 */

function Package(repo, ref) {
  if (!(this instanceof Package)) return new Package(repo, ref);
  this.repo = repo.replace(':', '/');
  this.token = auth.password || null;
  this.user = auth.login || null;
  this.setMaxListeners(Infinity);
  this.dir = process.cwd();
  this.ua = 'duo-package';
  this.resolved = false;
  this.ref = ref || '*';
  this._cache = true;
  Emitter.call(this);
}

/**
 * Inherit `EventEmitter`
 */

Package.prototype.__proto__ = Emitter.prototype;

/**
 * Set the directory to install into
 *
 * @param {String} dir
 * @return {Package} self
 * @api public
 */

Package.prototype.directory = function(dir) {
  if (!dir) return this.dir;
  this.dir = dir;
  return this;
};

/**
 * Get the local directory path
 *
 * @return {String}
 * @api public
 */

Package.prototype.path = function(path) {
  return join(this.dir, this.slug(), path || '');
};

/**
 * Get or set the User-Agent
 *
 * @param {String} ua (optional)
 * @return {Package|String}
 */

Package.prototype.useragent = function(ua) {
  if (!ua) return this.ua;
  this.ua = ua;
  return this;
};

/**
 * Authenticate with github
 *
 * @param {String} user
 * @param {String} token
 * @return {Package} self
 * @api public
 */

Package.prototype.auth = function(user, token) {
  this.user = user || this.user;
  this.token = token || this.token;
  return this;
};

/**
 * Ensure we're authenticated
 *
 * @return {Package}
 * @api private
 */

Package.prototype.authenticated = function(){
  var auth = this.user && this.token;
  if (auth) return this;
  throw this.error([
    'Github authentication error:',
    'make sure you have ~/.netrc or',
    'specify $GH_USER=<user> $GH_TOKEN=<token>.'
  ].join(' '));
};

/**
 * Resolve the reference on github
 *
 * @return {String}
 * @api public
 */

Package.prototype.resolve = wrapGenerator.mark(function $callee() {
  var slug, ref;

  return wrapGenerator(function $callee$($ctx0) {
    while (1) switch ($ctx0.prev = $ctx0.next) {
    case 0:
      this.authenticated();

      if (!(semver.valid(this.ref) || !semver.validRange(this.ref))) {
        $ctx0.next = 5;
        break;
      }

      this.debug('don\'t need to resolve %s', this.ref);
      this.resolved = this.ref;
      return $ctx0.abrupt("return", this.resolved);
    case 5:
      slug = this.repo + '@' + this.ref;
      this.resolved = this.resolved || cached(this.repo, this.ref);

      if (!this.resolved) {
        $ctx0.next = 10;
        break;
      }

      this.debug('resolved from cache %s', this.resolved);
      return $ctx0.abrupt("return", this.resolved);
    case 10:
      // resolving
      this.emit('resolving');

      this.debug('resolving');
      $ctx0.next = 14;
      return resolve(slug, this.user, this.token);
    case 14:
      ref = $ctx0.sent;

      if (ref) {
        $ctx0.next = 17;
        break;
      }

      throw this.error('%s: reference %s not found', this.slug(), this.ref);
    case 17:
      // resolved
      this.resolved = ref.name;

      (refs[this.repo] = refs[this.repo] || []).push(ref.name);
      this.debug('resolved');
      this.emit('resolve');
      return $ctx0.abrupt("return", ref.name);
    case 22:
    case "end":
      return $ctx0.stop();
    }
  }, $callee, this);
});

/**
 * Fetch the tarball from github
 * extracting to `dir`
 *
 * @param {Object} opts
 * @return {Package} self
 * @api public
 */

Package.prototype.fetch = wrapGenerator.mark(function $callee(opts) {
  var ref, url, cache, dest, pkg, store, cacheable, gens;

  return wrapGenerator(function $callee$($ctx1) {
    while (1) switch ($ctx1.prev = $ctx1.next) {
    case 0:
      this.authenticated();
      opts = opts || {};
      $ctx1.t0 = this.resolved;

      if ($ctx1.t0) {
        $ctx1.next = 7;
        break;
      }

      $ctx1.next = 6;
      return this.resolve();
    case 6:
      $ctx1.t0 = $ctx1.sent;
    case 7:
      ref = $ctx1.t0;
      url = fmt('%s/repos/%s/tarball/%s', api, this.repo, ref);
      cache = join(cachepath, this.slug() + '.tar.gz');
      dest = this.path();

      if (!inflight[dest]) {
        $ctx1.next = 15;
        break;
      }

      pkg = inflight[dest];
      $ctx1.next = 15;
      return function(done){ pkg.once('fetch', done); };
    case 15:
      // set package as inflight
      inflight[dest] = this;

      $ctx1.next = 18;
      return this.exists();
    case 18:
      if (!$ctx1.sent) {
        $ctx1.next = 24;
        break;
      }

      // already exists
      this.emit('fetching');

      this.debug('already exists');
      this.emit('fetch');
      delete inflight[dest];
      return $ctx1.abrupt("return", this);
    case 24:
      $ctx1.next = 26;
      return exists(cache);
    case 26:
      if (!$ctx1.sent) {
        $ctx1.next = 35;
        break;
      }

      // extracting
      this.emit('fetching');

      this.debug('extracting from cache')

      // extract;

      $ctx1.next = 31;
      return this.extract(cache, dest);
    case 31:
      // extracted
      this.emit('fetch');

      this.debug('extracted from cache');
      delete inflight[dest];
      return $ctx1.abrupt("return", this);
    case 35:
      // fetching
      this.emit('fetching');

      this.debug('fetching from %s', url);
      $ctx1.next = 39;
      return this.download(this.options(url));
    case 39:
      store = $ctx1.sent;
      cacheable = this._cache && semver.validRange(ref);
      gens = [];
      if (cacheable) gens.push(this.write(store, cache));
      gens.push(this.extract(store, dest));
      $ctx1.next = 46;
      return gens;
    case 46:
      // fetch
      this.emit('fetch');

      this.debug('fetched from %s', url);
      delete inflight[dest];
      return $ctx1.abrupt("return", this);
    case 50:
    case "end":
      return $ctx1.stop();
    }
  }, $callee, this);
});

/**
 * Check if the package exists.
 *
 * @return {Boolean}
 * @api private
 */

Package.prototype.exists = wrapGenerator.mark(function $callee() {
  return wrapGenerator(function $callee$($ctx2) {
    while (1) switch ($ctx2.prev = $ctx2.next) {
    case 0:
      $ctx2.next = 2;
      return exists(this.path());
    case 2:
      return $ctx2.abrupt("return", $ctx2.sent);
    case 3:
    case "end":
      return $ctx2.stop();
    }
  }, $callee, this);
});

/**
 * Get the slug
 *
 * @return {String}
 * @api public
 */

Package.prototype.toString =
Package.prototype.slug = function() {
  var repo = this.repo.replace('/', '-');
  var ref = this.resolved || this.ref;
  return repo + '@' + ref;
};

/**
 * Return request options for `url`.
 *
 * @param {String} url
 * @param {Object} [opts]
 * @return {Object}
 * @api private
 */

Package.prototype.options = function(url, other){
  var token = this.token;
  var user = this.user;

  var opts = {
    url: url,
    headers: { 'User-Agent': this.ua }
  };

  if (other) {
    for (var k in other) opts[k] = other[k];
  }

  if (token) opts.headers.Authorization = 'Bearer ' + token;

  return opts;
};

/**
 * Reliably download the package.
 * Returns a store to be piped around.
 *
 * @param {Object} opts
 * @return {Function}
 * @api private
 */

Package.prototype.download = function(opts) {
  var store = enstore();
  var gzip = store.createWriteStream();
  var self = this;
  var prev = 0;
  var len = 0;

  return function(fn) {
    var req = request(opts);
    debug(curl(opts));

    // handle any errors from the request
    req.on('error', error);

    store.on('end', function() {
      return fn(null, store);
    });

    req.on('response', function(res) {
      var status = res.statusCode;
      var headers = res.headers;

      // github doesn't always return a content-length (wtf?)
      var total = +headers['content-length'];

      // Ensure that we have the write status code
      if (status < 200 || status >= 300) {
        return fn(self.error('returned with status code: %s', status));
      }

      // listen for data and emit percentages
      req.on('data', function(buf) {
        len += buf.length;
        var percent = Math.round(len / total * 100);
        // TODO figure out what to do when no total
        if (!total || prev >= percent) return;
        self.debug('progress %s', percent);
        self.emit('progress', percent);
        prev = percent;
      });

      // pipe data into gunzip, then in-memory store
      req.pipe(zlib.createGunzip())
        .on('error', error)
        .pipe(gzip);
    });

    function error(err) {
      return fn(self.error(err));
    }
  }
};

/**
 * Extract the tarball
 *
 * @param {Enstore|String} store
 * @param {String} dest
 * @return {Function}
 * @api private
 */

Package.prototype.extract = function(store, dest) {
  var self = this;

  // create a stream
  var stream = 'string' == typeof store
    ? read(store)
    : store.createReadStream();

  return function(fn) {
    stream
      .on('error', error)
      .pipe(tar.extract(dest, { strip: 1 }))
      .on('error', error)
      .on('finish', fn);

    function error(err) {
      return fn(self.error(err));
    }
  };
};

/**
 * Write the tarball
 *
 * @param {Enstore} store
 * @param {String} dest
 * @return {Function}
 * @api private
 */

Package.prototype.write = function(store, dest) {
  var read = store.createReadStream();
  var stream = write(dest);
  var self = this;

  return function(fn) {
    read.pipe(stream)
      .on('error', error)
      .on('finish', fn)

    function error(err) {
      return fn(self.error(err));
    }
  };
};

/**
 * Debug
 *
 * @param {String} msg
 * @param {Mixed, ...} args
 * @return {Package}
 * @api private
 */

Package.prototype.debug = function(msg) {
  var args = [].slice.call(arguments, 1);
  msg = fmt('%s: %s', this.slug(), msg);
  debug.apply(debug, [msg].concat(args));
  return this;
};

/**
 * Error
 *
 * @param {String} msg
 * @return {Error}
 * @api private
 */

Package.prototype.error = function(msg) {
  msg = fmt('%s: %s', this.slug(), msg.message || msg);
  var args = [].slice.call(arguments, 1);
  return new Error(fmt.apply(null, [msg].concat(args)));
};

/**
 * Get a cached `repo`, `ref`.
 *
 * @param {String} repo
 * @param {String} ref
 * @return {String}
 * @api private
 */

function cached(repo, ref){
  var revs = refs[repo] || [];

  for (var i = 0; i < revs.length; ++i) {
    try {
      if (semver.satisfies(revs[i], ref)) return revs[i];
    } catch (e) {
      if (revs[i] == ref) return revs[i];
    }
  }
}

/**
 * Display the curl request
 *
 * @param {Object} opts
 * @return {String}
 * @api private
 */

function curl(opts) {
  var arr = ['curl'];

  // options
  arr.push('-v');
  arr.push('-L');

  // headers
  Object
    .keys(opts.headers)
    .forEach(function(header) {
      arr.push(fmt('-H "%s: %s"', header, opts.headers[header]));
    });

  // url
  arr.push(opts.url);

  return arr.join(' ');
}
